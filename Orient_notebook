{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "a59d4881",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"##delta = d_2[np.argsort(R_In)[0]]-d_2[np.argsort(reflect3(d_2, teta))[0]] #поправка на смещение нуля d\n",
    "##print(delta)\n",
    "#print(scipy.optimize.curve_fit(reflect4, d_2[5:12], R_Gr[5:12], bounds = ([-200, 0], [-100, 10000]), full_output = True, method = \"trf\"))\n",
    "##print(scipy.optimize.curve_fit(reflect4, d_2[5:], R_Gr[5:], p0 = [-100, 300], sigma = err_Gr[5:],  bounds = ([-1000, 0], [-1, 10000]), full_output = True, method = \"trf\"))\n",
    "\n",
    "##eps_3 = complex(*scipy.optimize.curve_fit(reflect4, d_2[5:12], R_Gr[5:12], bounds = ([-1000, 0], [0, 1000]))[0])\n",
    "##print(eps_3)\n",
    "#eps_3 = complex(-1, 261)\"\"\"\n",
    "print(sum(scipy.optimize.curve_fit(reflect4, d_2, R_Gr, bounds = ([-(2+1)*10, 0], [-2*10, 1000]), method = \"trf\", full_output=True)[2]['fvec']))\n",
    "a = []\n",
    "b = []\n",
    "c = []\n",
    "for i in range(100):\n",
    "    for j in range(100):\n",
    "        a.append( scipy.optimize.curve_fit(reflect4, d_2, R_Gr, bounds = ([-(i+1)*10, j*10], [-i, (j+1)*10]), method = \"trf\")[0][0])\n",
    "        c.append( scipy.optimize.curve_fit(reflect4, d_2, R_Gr, bounds = ([-(i+1)*10, j*10], [-i, (j+1)*10]), method = \"trf\")[0][1])\n",
    "        b.append(sum(scipy.optimize.curve_fit(reflect4, d_2, R_Gr, bounds = ([-(i+1)*10, j*10], [-i, (j+1)*10]), method = \"trf\", full_output=True)[2]['fvec']))     \n",
    "#eps_3 = complex(*scipy.optimize.curve_fit(reflect4, d_2[5:12], R_Gr[5:12])[0])\n",
    "#eps_3\n",
    "a = np.array(a)\n",
    "b = np.array(b)\n",
    "c = np.array(c)\n",
    "\n",
    "plt.plot(a, b)\n",
    "plt.xlabel('optimal Im e,  in limits Re[-1000, 0 с шагом 10] ', fontsize=16)\n",
    "plt.ylabel('residual values')\n",
    "plt.show()\n",
    "\n",
    "\"\"\"fig = plt.figure()\n",
    "ax = fig.add_subplot(1, 1, 1, projection='3d')\n",
    "\n",
    "\n",
    "ax.plot_surface(a, c, b)\"\"\"\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "f91c4595",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import scipy \n",
    "import math\n",
    "import matplotlib.pyplot as plt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "0e8a0f28",
   "metadata": {},
   "outputs": [],
   "source": [
    "n_1=complex(1.531, -0.002) # комплексный показатель преломления призмы (Zeonex)\n",
    "eps_1=n_1**2 # диэлектрическая проницаемость призмы (Zeonex)\n",
    "eps_2=1 # диэлектрическая проницаемость воздуха\n",
    "#eps_4 = complex(-18.474508935284483+0.006568625288807081j) по Друде-Лоренцу\n",
    "eps_4=complex(-17.3, 7.12) #InSb из telegram\n",
    "#teta_0=41.0*np.pi/180 #угол падения на призму ??????\n",
    "#teta_0=40.9*np.pi/180  #угол падения на призму ??????\n",
    "#teta = np.pi/4-np.arcsin(np.sin(np.pi/4-teta_0)/n_1.real) #угол падения на выходе из призмы \n",
    "#teta = 42.16*np.pi/180 #файл 3 слоя\n",
    "wavelength=197*10**(-6)\n",
    "d_3 = 17*10**(-9) # толщина графена "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "b5789892",
   "metadata": {},
   "outputs": [],
   "source": [
    "file1 = open(\"R(gap)_InSb.txt\", \"r\").read()  #файлы перепутаны!\n",
    "file2 = open(\"R(gap)_InSb+Graphene.txt\", \"r\").read()\n",
    "def string_to_np_array(input_string):\n",
    "    divisions = input_string.split('\\n')\n",
    "    result_2d_list = np.array([list(map(float, division.split('\\t'))) for division in divisions])\n",
    "    return result_2d_list\n",
    "Data = string_to_np_array(file1)[::, :2:]\n",
    "file1 = string_to_np_array(file1)\n",
    "file2 = string_to_np_array(file2)\n",
    "column = file2[::, 1:2:]\n",
    "#Data = np.append (file, column,  axis= 1 )\n",
    "file2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "fb46e223",
   "metadata": {},
   "outputs": [],
   "source": [
    "a = [1, 2, 3]\n",
    "a[1:2:]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "7734372e",
   "metadata": {},
   "outputs": [],
   "source": [
    "file"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "6a00eac5",
   "metadata": {},
   "outputs": [],
   "source": [
    "d_2 = file1[::, 0]*10**(-6) #уже переведено в микроны\n",
    "R_In = file2[::, 1]\n",
    "R_Gr = file1[::, 1]\n",
    "err_In = file2[::, 2]\n",
    "err_Gr = file1[::, 2]\n",
    "\n",
    "noise_Gr = 9\n",
    "\n",
    "plt.plot(d_2, R_In, '--r')\n",
    "plt.plot(d_2, R_Gr, ':b')\n",
    "\n",
    "d_min = d_2[19] #экспериментальный минимум\n",
    "print(R_Gr)\n",
    "plt.show()\n",
    "print(d_2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "c10ccd37",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\"#Параметры InSb в модели Друде Лоренца\n",
    "wp=0.578*10**14 #плазменная частота (рад/с)\n",
    "gp=1/5.16*10**3  #частота столкновений (рад/с)\n",
    "wl=3.4*10**13 #частота Лоренца (рад/с)\n",
    "gl=1/3*10**12 #Лоренцева частота столкновений (рад/с)\n",
    "Al=2.02 #Амплитуда в модели Лоренца\n",
    "eps0=15.86 #диэлектрическая проницаемость на бесконечности\n",
    "\n",
    "wavelength=197*10**(-6)  #длина волны излучения\n",
    "f=3*10**8/wavelength  #частота излучения\n",
    "w=6.28*f  #круговая частота\n",
    "\n",
    "#Модель Друде-Лоренца для проницаемости InSb\n",
    "eps_4=eps0-wp**2/complex(w**2, gp*w)+Al*wl**2/complex(wl**2-w**2, -gl*w) \n",
    "print(eps_4)\n",
    "d_2=np.linspace(0*10**(-6), 450*10**(-6), 450)  #величина зазора между призмой и InSb\n",
    "d_3=4.7*10**(-6) \n",
    "teta=42.21*np.pi/180  #угол падения в призме\n",
    "\n",
    "# f=1.5*10**12:0.01*10**12:2*10**12 \n",
    "# w=6.28*f \n",
    "# \n",
    "# #Модель Друде-Лоренца для проницаемости InSb\n",
    "# for j=1:1:length(w)\n",
    "#     eps(j)=eps0-wp**2/(w(j)**2+i*gp*w(j))+Al*wl**2/(wl**2-w(j)**2-i*gl*w(j)) \n",
    "# end \n",
    "# plot (f, real(eps), f, imag(eps)) \"\"\"\"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "968f417e",
   "metadata": {},
   "outputs": [],
   "source": [
    "#угол не подгоняется\n",
    "\"\"\"\"def reflect3(d):\n",
    "    \n",
    "    kz_1=np.sqrt(eps_1)*np.cos(teta)\n",
    "    kz_2=np.sqrt(eps_2-eps_1*np.sin(teta)**2)\n",
    "    kz_3=np.sqrt(eps_4-eps_1*np.sin(teta)**2)\n",
    "    \n",
    "#Коэффициенты отражения\n",
    "    r_12=(eps_2*kz_1-eps_1*kz_2)/(eps_2*kz_1+eps_1*kz_2)\n",
    "    r_23=(eps_4*kz_2-eps_2*kz_3)/(eps_4*kz_2+eps_2*kz_3)\n",
    "\n",
    "#Коэффициенты пропускания\n",
    "    t_12=2*kz_1*np.sqrt(eps_1*eps_2)/(eps_2*kz_1+eps_1*kz_2) #???\n",
    "    t_23=2*kz_2*np.sqrt(eps_2*eps_4)/(eps_4*kz_2+eps_2*kz_3)\n",
    "   \n",
    " #Матрица пропускания\n",
    "    S1=np.array([[1/t_12, r_12/t_12], [r_12/t_12, 1/t_12]])    \n",
    "    \n",
    "#Расчёт R    \n",
    "    R = []\n",
    "    for j in range(len(d)):   #1:1:length(d_2)\n",
    "        S2=np.array([[np.exp(-complex(0, 1)*(2*np.pi/wavelength)*kz_2*d[j])/t_23, \n",
    "         r_23*np.exp(-complex(0, 1)*(2*np.pi/wavelength)*kz_2*d[j])/t_23],  \n",
    "         [r_23*np.exp(complex(0, 1)*(2*np.pi/wavelength)*kz_2*d[j])/t_23, \n",
    "         np.exp(complex(0, 1)*(2*np.pi/wavelength)*kz_2*d[j])/t_23]])\n",
    "        S=S1@S2\n",
    "        R += [abs(S[1][0]/S[0][0])]\n",
    "    print(S)\n",
    "    return(np.array(R))\n",
    "\"\"\"\n",
    "\n",
    "#угол подгоняется\n",
    "def reflect3(d, angle):\n",
    "    \n",
    "    kz_1=np.sqrt(eps_1)*np.cos(angle)\n",
    "    kz_2=np.sqrt(eps_2-eps_1*np.sin(angle)**2)\n",
    "    kz_3=np.sqrt(eps_4-eps_1*np.sin(angle)**2)\n",
    "    \n",
    "#Коэффициенты отражения\n",
    "    r_12=(eps_2*kz_1-eps_1*kz_2)/(eps_2*kz_1+eps_1*kz_2)\n",
    "    r_23=(eps_4*kz_2-eps_2*kz_3)/(eps_4*kz_2+eps_2*kz_3)\n",
    "\n",
    "#Коэффициенты пропускания\n",
    "    t_12=2*kz_1*np.sqrt(eps_1*eps_2)/(eps_2*kz_1+eps_1*kz_2) #???\n",
    "    t_23=2*kz_2*np.sqrt(eps_2*eps_4)/(eps_4*kz_2+eps_2*kz_3)\n",
    "   \n",
    " #Матрица пропускания\n",
    "    S1=np.array([[1/t_12, r_12/t_12], [r_12/t_12, 1/t_12]])    \n",
    "    \n",
    "#Расчёт R    \n",
    "    R = []\n",
    "    for j in range(len(d)):   #1:1:length(d_2)\n",
    "        S2=np.array([[np.exp(-complex(0, 1)*(2*np.pi/wavelength)*kz_2*d_2[j])/t_23, r_23*np.exp(-complex(0, 1)*(2*np.pi/wavelength)*kz_2*d_2[j])/t_23],  [r_23*np.exp(complex(0, 1)*(2*np.pi/wavelength)*kz_2*d_2[j])/t_23, np.exp(complex(0, 1)*(2*np.pi/wavelength)*kz_2*d_2[j])/t_23]])\n",
    "        S=S1@S2\n",
    "        R += [abs(S[1][0]/S[0][0])]\n",
    "    return(np.array(R))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "7ca49d5e",
   "metadata": {},
   "outputs": [],
   "source": [
    "#teta = 0.7291350762966604 #из предыдущего файла\n",
    "#teta = scipy.optimize.curve_fit(reflect3, d_2, R_In, bounds = (0.65, 0.75))[0][0]\n",
    "teta = scipy.optimize.curve_fit(reflect3, d_2[4:11], R_In[4:11], bounds = (0.65, 0.75))[0][0] #подгонка только в окрестности минимума\n",
    "print(teta*180/np.pi)\n",
    "#reflect3(d_2, teta)\n",
    "#print(scipy.optimize.curve_fit(reflect4, d_2, R_Gr))\n",
    "\n",
    "#eps_3 = complex(*scipy.optimize.curve_fit(reflect4, d_2, R_Gr)[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "7020c038",
   "metadata": {},
   "outputs": [],
   "source": [
    "def reflect4(d_2, e3_re, e3_im):\n",
    "    eps_3 = complex(e3_re, e3_im)\n",
    "    kz_1=np.sqrt(eps_1)*np.cos(teta)\n",
    "    kz_2=np.sqrt(eps_2-eps_1*np.sin(teta)**2)\n",
    "    kz_3=np.sqrt(eps_3-eps_1*np.sin(teta)**2)\n",
    "    kz_4=np.sqrt(eps_4-eps_1*np.sin(teta)**2)\n",
    "\n",
    "\n",
    "#Коэффициенты отражения\n",
    "    r_12=(eps_2*kz_1-eps_1*kz_2)/(eps_2*kz_1+eps_1*kz_2)\n",
    "    r_23=(eps_3*kz_2-eps_2*kz_3)/(eps_3*kz_2+eps_2*kz_3)\n",
    "    r_34=(eps_4*kz_3-eps_3*kz_4)/(eps_4*kz_3+eps_3*kz_4)\n",
    "\n",
    "#Коэффициенты пропускания\n",
    "    t_12=2*kz_1*np.sqrt(eps_1*eps_2)/(eps_2*kz_1+eps_1*kz_2)\n",
    "    t_23=2*kz_2*np.sqrt(eps_2*eps_3)/(eps_3*kz_2+eps_2*kz_3)\n",
    "    t_34=2*kz_3*np.sqrt(eps_3*eps_4)/(eps_4*kz_3+eps_3*kz_4)\n",
    "\n",
    "#Матрица преобразования\n",
    "    S1=np.array([[1/t_12, r_12/t_12], [r_12/t_12, 1/t_12]])\n",
    "    S3=np.array([[np.exp(-complex(0, 1)*(2*np.pi/wavelength)*kz_3*d_3)/t_34,\n",
    "     r_34*np.exp(-complex(0, 1)*(2*np.pi/wavelength)*kz_3*d_3)/t_34],\n",
    "     [r_34*np.exp(complex(0, 1)*(2*np.pi/wavelength)*kz_3*d_3)/t_34, \n",
    "     np.exp(complex(0, 1)*(2*np.pi/wavelength)*kz_3*d_3)/t_34]])\n",
    "    \n",
    "    R = []\n",
    "    for j in range(len(d_2)):   #1:1:length(d_2)\n",
    "        S2=np.array([[np.exp(-complex(0, 1)*(2*np.pi/wavelength)*kz_2*d_2[j])/t_23, r_23*np.exp(-complex(0, 1)*(2*np.pi/wavelength)*kz_2*d_2[j])/t_23],  [r_23*np.exp(complex(0, 1)*(2*np.pi/wavelength)*kz_2*d_2[j])/t_23, np.exp(complex(0, 1)*(2*np.pi/wavelength)*kz_2*d_2[j])/t_23]])\n",
    "        S=S1@S2@S3\n",
    "        R += [abs(S[1][0]/S[0][0])]\n",
    "    \n",
    "    return np.array(R)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "e81844fc",
   "metadata": {},
   "outputs": [],
   "source": [
    "R_Gr[10:30]/d_2[10:30] #проверка совпадения размерностей//"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "752b414c",
   "metadata": {},
   "outputs": [],
   "source": [
    "%history -n -o -p -g -f ori_hist_2 "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "438224fe",
   "metadata": {},
   "outputs": [],
   "source": [
    "pwd"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 5
}
